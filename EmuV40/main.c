#include "config.h"
#include <stdio.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <SDL.h>
#include <stdbool.h>
#include <Windows.h>

#include "parsecl.h"
#include "types.h"
#include "cpu.h"
#include "ports.h"
#include "vera.h"
#include "ppu.h"
#include "glue.h"
#include "debug.h"
#include "v40io.h"
#include "joystick.h"
#include "i8255.h"
//#include "i8253.h"
#include "pit.h"
#include "gamepad.h"
#include "console.h"
#include "timing.h"
#include "ay8910.h"
#include "tms9918a.h"

#include "f18a.h"

//#define USE_VERA
#define USE_TMS9918A
#define TICKS_FOR_NEXT_FRAME (1000 / 60)
//void parsecl(int argc, char* argv[]);

uint8_t running = 1;
uint8_t MHZ = 8;
bool log_video = false;
bool enable_midline = false;
bool warp_mode = false;
bool grab_mouse = false;
bool disable_emu_cmd_keys = false;
bool reset_requested = false;
bool debugger_enabled = false;
bool console_enabled = true;
bool hard_reset = false;
bool trace_mode = false;

bool fullscreen = false;
int window_scale = 1;
float screen_x_scale = 1.0;
float window_opacity = 1.0;
char* scale_quality = "best";

//struct tms9918a *tms;
//struct tms9918a_renderer *tms_renderer;


bool new_frame = false;
uint32_t frame_count2 = 0;
uint8_t* bios;
static uint64_t starttick, endtick;

bool key_r = false;
bool key_s = false;
bool key_l = false;

uint8_t scrollX = 0, scrollY = 0;

int sdl_live;
static double perfFreq;
static double lastTime;
static int tickCount = 0;
static char tempBuffer[256];

static uint8_t default_font[] = {
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,		//   0  nul
			0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E,		//   1  so
			0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E,		//   2  stx
			0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00,		//   3  etx
			0x10, 0x38, 0x7C, 0xFE,	0x7C, 0x38, 0x10, 0x00,		//   4  eot
			0x38, 0x7C, 0x38, 0xFE,	0xFE, 0x7C, 0x38, 0x7C,		//   5  enq
			0x10, 0x10, 0x38, 0x7C,	0xFE, 0x7C, 0x38, 0x7C,		//   6  ack
			0x00, 0x00, 0x18, 0x3C,	0x3C, 0x18, 0x00, 0x00,		//   7  bel
			0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF,		//   8  bs
			0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00,		//   9  t
			0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF,		//  10  lf
			0x0F, 0x07, 0x0F, 0x7D, 0xCC, 0xCC, 0xCC, 0x78,		//  11  vt
			0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18,		//  12  ff
			0x3F, 0x33, 0x3F, 0x30, 0x30, 0x70, 0xF0, 0xE0,		//  13  cr
			0x7F, 0x63, 0x7F, 0x63, 0x63, 0x67, 0xE6, 0xC0,		//  14  so
			0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99,		//  15  si
			0x80, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0x80, 0x00,		//  16  dle
			0x02, 0x0E, 0x3E, 0xFE,	0x3E, 0x0E, 0x02, 0x00,		//  17  dc1
			0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18,		//  18  dc2
			0x66, 0x66, 0x66, 0x66,	0x66, 0x00, 0x66, 0x00,		//  19  dc3
			0x7F, 0xDB, 0xDB, 0x7B,	0x1B, 0x1B, 0x1B, 0x00,		//  20x  dc4
			0x3E, 0x63, 0x38, 0x6C,	0x6C, 0x38, 0xCC, 0x78,		//  21  nak
			0x00, 0x00, 0x00, 0x00,	0x7E, 0x7E, 0x7E, 0x00,		//  22  syn
			0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF,		//  23  etb
			0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00,		//  24  can
			0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00,		//  25  em
			0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00,		//  26  sub
			0x00, 0x30, 0x60, 0xFE,	0x60, 0x30, 0x00, 0x00,		//  27  esc
			0x00, 0x00, 0xC0, 0xC0,	0xC0, 0xFE, 0x00, 0x00,		//  28  fs
			0x00, 0x24, 0x66, 0xFF,	0x66, 0x24, 0x00, 0x00,		//  29  gs
			0x00, 0x18, 0x3C, 0x7E,	0xFF, 0xFF, 0x00, 0x00,		//  30  rs
			0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00,		//  31  us
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,		//  32  space
			0x30, 0x78, 0x78, 0x30,	0x30, 0x00, 0x30, 0x00,		//  33  !
			0x6C, 0x6C, 0x6C, 0x00,	0x00, 0x00, 0x00, 0x00,		//  34  "
			0x6C, 0x6C, 0xFE, 0x6C,	0xFE, 0x6C, 0x6C, 0x00,		//  35  #
			0x30, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x30, 0x00,		//  36  $
			0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00,		//  37  %
			0x38, 0x6C, 0x38, 0x76,	0xDC, 0xCC, 0x76, 0x00,		//  38  &
			0x60, 0x60, 0xC0, 0x00,	0x00, 0x00, 0x00, 0x00,		//  39  '
			0x18, 0x30, 0x60, 0x60,	0x60, 0x30, 0x18, 0x00,		//  40  (
			0x60, 0x30, 0x18, 0x18,	0x18, 0x30, 0x60, 0x00,		//  41  )
			0x00, 0x66, 0x3C, 0xFF,	0x3C, 0x66, 0x00, 0x00,		//  42  *
			0x00, 0x30, 0x30, 0xFC,	0x30, 0x30, 0x00, 0x00,		//  43  +
			0x00, 0x00, 0x00, 0x00,	0x00, 0x30, 0x30, 0x60,		//  44  ,
			0x00, 0x00, 0x00, 0xFC,	0x00, 0x00, 0x00, 0x00,		//  45  -
			0x00, 0x00, 0x00, 0x00,	0x00, 0x30, 0x30, 0x00,		//  46  .
			0x06, 0x0C, 0x18, 0x30,	0x60, 0xC0, 0x80, 0x00,		//  47  /
			0x7C, 0xC6, 0xCE, 0xDE,	0xF6, 0xE6, 0x7C, 0x00,		//  48  0
			0x30, 0x70, 0x30, 0x30,	0x30, 0x30, 0xFC, 0x00,		//  49  1
			0x78, 0xCC, 0x0C, 0x38,	0x60, 0xCC, 0xFC, 0x00,		//  50  2
			0x78, 0xCC, 0x0C, 0x38,	0x0C, 0xCC, 0x78, 0x00,		//  51  3
			0x1C, 0x3C, 0x6C, 0xCC,	0xFE, 0x0C, 0x1E, 0x00,		//  52  4
			0xFC, 0xC0, 0xF8, 0x0C,	0x0C, 0xCC, 0x78, 0x00,		//  53  5
			0x38, 0x60, 0xC0, 0xF8, 0xCC, 0xCC, 0x78, 0x00,		//  54  6
			0xFC, 0xCC, 0x0C, 0x18,	0x30, 0x30, 0x30, 0x00,		//  55  7
			0x78, 0xCC, 0xCC, 0x78,	0xCC, 0xCC, 0x78, 0x00,		//  56  8
			0x78, 0xCC, 0xCC, 0x7C,	0x0C, 0x18, 0x70, 0x00,		//  57  9
			0x00, 0x30, 0x30, 0x00,	0x00, 0x30, 0x30, 0x00,		//  58  :
			0x00, 0x30, 0x30, 0x00,	0x00, 0x30, 0x30, 0x60,		//  59  //
			0x18, 0x30, 0x60, 0xC0,	0x60, 0x30, 0x18, 0x00,		//  60x  <
			0x00, 0x00, 0xFC, 0x00,	0x00, 0xFC, 0x00, 0x00,		//  61  =
			0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00,		//  62  >
			0x78, 0xCC, 0x0C, 0x18,	0x30, 0x00, 0x30, 0x00,		//  63  ?
			0x7C, 0xC6, 0xDE, 0xDE,	0xDE, 0xC0, 0x78, 0x00,		//  64  @
			0x30, 0x78, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0x00,		//  65  A
			0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00,		//  66  B
			0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00,		//  67  C
			0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00,		//  68  D
			0xFE, 0x62, 0x68, 0x78,	0x68, 0x62, 0xFE, 0x00,		//  69  E
			0xFE, 0x62, 0x68, 0x78,	0x68, 0x60, 0xF0, 0x00,		//  70x  F
			0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00,		//  71  G
			0xCC, 0xCC, 0xCC, 0xFC,	0xCC, 0xCC, 0xCC, 0x00,		//  72  
			0x78, 0x30, 0x30, 0x30,	0x30, 0x30, 0x78, 0x00,		//  73  I
			0x1E, 0x0C, 0x0C, 0x0C,	0xCC, 0xCC, 0x78, 0x00,		//  74  J
			0xE6, 0x66, 0x6C, 0x78,	0x6C, 0x66, 0xE6, 0x00,		//  75  K
			0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00,		//  76  L
			0xC6, 0xEE, 0xFE, 0xFE,	0xD6, 0xC6, 0xC6, 0x00,		//  77  M
			0xC6, 0xE6, 0xF6, 0xDE,	0xCE, 0xC6, 0xC6, 0x00,		//  78  N
			0x38, 0x6C, 0xC6, 0xC6,	0xC6, 0x6C, 0x38, 0x00,		//  79  O
			0xFC, 0x66, 0x66, 0x7C,	0x60, 0x60, 0xF0, 0x00,		//  80x  P
			0x78, 0xCC, 0xCC, 0xCC,	0xDC, 0x78, 0x1C, 0x00,		//  81  Q
			0xFC, 0x66, 0x66, 0x7C,	0x6C, 0x66, 0xE6, 0x00,		//  82  R
			0x78, 0xCC, 0xE0, 0x70,	0x1C, 0xCC, 0x78, 0x00,		//  83  S
			0xFC, 0xB4, 0x30, 0x30,	0x30, 0x30, 0x78, 0x00,		//  84  T
			0xCC, 0xCC, 0xCC, 0xCC,	0xCC, 0xCC, 0xFC, 0x00,		//  85  U
			0xCC, 0xCC, 0xCC, 0xCC,	0xCC, 0x78, 0x30, 0x00,		//  86  V
			0xC6, 0xC6, 0xC6, 0xD6,	0xFE, 0xEE, 0xC6, 0x00,		//  87  W
			0xC6, 0xC6, 0x6C, 0x38,	0x38, 0x6C, 0xC6, 0x00,		//  88  X
			0xCC, 0xCC, 0xCC, 0x78,	0x30, 0x30, 0x78, 0x00,		//  89  Y
			0xFE, 0xC6, 0x8C, 0x18,	0x32, 0x66, 0xFE, 0x00,		//  90x  Z
			0x78, 0x60, 0x60, 0x60,	0x60, 0x60, 0x78, 0x00,		//  91  [
			0xC0, 0x60, 0x30, 0x18,	0x0C, 0x06, 0x02, 0x00,		//  92  backslas
			0x78, 0x18, 0x18, 0x18,	0x18, 0x18, 0x78, 0x00,		//  93  ]
			0x10, 0x38, 0x6C, 0xC6,	0x00, 0x00, 0x00, 0x00,		//  94  ^
			0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x00, 0xFF,		//  95  _
			0x30, 0x30, 0x18, 0x00,	0x00, 0x00, 0x00, 0x00,		//  96  `
			0x00, 0x00, 0x78, 0x0C,	0x7C, 0xCC, 0x76, 0x00,		//  97  a
			0xE0, 0x60, 0x60, 0x7C,	0x66, 0x66, 0xDC, 0x00,		//  98  b
			0x00, 0x00, 0x78, 0xCC,	0xC0, 0xCC, 0x78, 0x00,		//  99  c
			0x1C, 0x0C, 0x0C, 0x7C,	0xCC, 0xCC, 0x76, 0x00,		// 10x0x  d
			0x00, 0x00, 0x78, 0xCC,	0xFC, 0xC0, 0x78, 0x00,		// 10x1  e
			0x38, 0x6C, 0x60, 0xF0,	0x60, 0x60, 0xF0, 0x00,		// 10x2  f
			0x00, 0x00, 0x76, 0xCC,	0xCC, 0x7C, 0x0C, 0xF8,		// 10x3  g
			0xE0, 0x60, 0x6C, 0x76,	0x66, 0x66, 0xE6, 0x00,		// 10x4  
			0x30, 0x00, 0x70, 0x30,	0x30, 0x30, 0x78, 0x00,		// 10x5  i
			0x0C, 0x00, 0x0C, 0x0C,	0x0C, 0xCC, 0xCC, 0x78,		// 10x6  j
			0xE0, 0x60, 0x66, 0x6C,	0x78, 0x6C, 0xE6, 0x00,		// 10x7  k
			0x70, 0x30, 0x30, 0x30,	0x30, 0x30, 0x78, 0x00,		// 10x8  l
			0x00, 0x00, 0xCC, 0xFE,	0xFE, 0xD6, 0xC6, 0x00,		// 10x9  m
			0x00, 0x00, 0xF8, 0xCC,	0xCC, 0xCC, 0xCC, 0x00,		// 110x  n
			0x00, 0x00, 0x78, 0xCC,	0xCC, 0xCC, 0x78, 0x00,		// 111  o
			0x00, 0x00, 0xDC, 0x66,	0x66, 0x7C, 0x60, 0xF0,		// 112  p
			0x00, 0x00, 0x76, 0xCC,	0xCC, 0x7C, 0x0C, 0x1E,		// 113  q
			0x00, 0x00, 0xDC, 0x76,	0x66, 0x60, 0xF0, 0x00,		// 114  r
			0x00, 0x00, 0x7C, 0xC0,	0x78, 0x0C, 0xF8, 0x00,		// 115  s
			0x10, 0x30, 0x7C, 0x30,	0x30, 0x34, 0x18, 0x00,		// 116  t
			0x00, 0x00, 0xCC, 0xCC,	0xCC, 0xCC, 0x76, 0x00,		// 117  u
			0x00, 0x00, 0xCC, 0xCC,	0xCC, 0x78, 0x30, 0x00,		// 118  v
			0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xFE, 0x6C, 0x00,		// 119  w
			0x00, 0x00, 0xC6, 0x6C,	0x38, 0x6C, 0xC6, 0x00,		// 120x  x
			0x00, 0x00, 0xCC, 0xCC,	0xCC, 0x7C, 0x0C, 0xF8,		// 121  y
			0x00, 0x00, 0xFC, 0x98,	0x30, 0x64, 0xFC, 0x00,		// 122  z
			0x1C, 0x30, 0x30, 0xE0,	0x30, 0x30, 0x1C, 0x00,		// 123  {
			0x18, 0x18, 0x18, 0x00,	0x18, 0x18, 0x18, 0x00,		// 124  |
			0xE0, 0x30, 0x30, 0x1C,	0x30, 0x30, 0xE0, 0x00,		// 125  }
			0x76, 0xDC, 0x00, 0x00,	0x00, 0x00, 0x00, 0x00,		// 126  ~
			0x00, 0x10, 0x38, 0x6C,	0xC6, 0xC6, 0xFE, 0x00		// 127  del
};

static uint32_t load_bios(const char* filename) {
	FILE* file = fopen(filename, "rb");
	if (file == NULL)
		return -1;
	fseek(file, 0L, SEEK_END);
	uint32_t readsize = ftell(file);
	rewind(file);

	bios = (uint8_t*)malloc(sizeof(uint8_t) * readsize);
	if (bios == NULL)
		return -1;
	fread(bios, sizeof(uint8_t) * readsize, 1, file);

	if (readsize <= 0)
		return 0;
	memcpy(cpu.RAM + 0x100000 - readsize, bios, readsize);
	printf("BIOS %s loaded at 0x%05X (%d KB)\n", filename, 0x100000 - readsize, readsize >> 10);
	memset(cpu.readonly + 0x100000 - readsize, 1, readsize);
	fclose(file);
	free(bios);
	return readsize;
}

const int fm_midi_notes[] = {//MIDI note number
  15289, 14431, 13621, 12856, 12135, 11454, 10811, 10204,//0-o7
  9631, 9091, 8581, 8099, 7645, 7215, 6810, 6428,//8-15
  6067, 5727, 5405, 5102, 4816, 4545, 4290, 4050,//16-23
  3822, 3608, 3405, 3214, 3034, 2863, 2703, 2551,//24-31
  2408, 2273, 2145, 2025, 1911, 1804, 1703, 1607,//32-39
  1517, 1432, 1351, 1276, 1204, 1136, 1073, 1012,//40-47
  956, 902, 851, 804, 758, 716, 676, 638,//48-55
  602, 568, 536, 506, 478, 451, 426, 402,//56-63
  379, 358, 338, 319, 301, 284, 268, 253,//64-71
  239, 225, 213, 201, 190, 179, 169, 159,//72-79
  150, 142, 134, 127, 119, 113, 106, 100,//80-87
  95, 89, 84, 80, 75, 71, 67, 63,//88-95
  60, 56, 53, 50, 47, 45, 42, 40,//96-103
  38, 36, 34, 32, 30, 28, 27, 25,//104-111
  24, 22, 21, 20, 19, 18, 17, 16,//112-119
  15, 14, 13, 13, 12, 11, 11, 10,//120-127
  0//off
};

void emu_init() {

	cpu_reset();
	uint32_t size = load_bios("bios.bin");
	if (size <= 0) {
		printf("Error loading BIOS");
	}

	printf("Initializing emulated hardware:\n");
	ports_init();

	printf("  - V40: ");
	initv40io();
	puts("OK");

	printf("  - PPU: ");
	SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS | SDL_INIT_GAMECONTROLLER | SDL_INIT_AUDIO | SDL_INIT_TIMER);
	sdl_live = 1;
#ifdef USE_VERA
	vera_init(window_scale, screen_x_scale, scale_quality, fullscreen, window_opacity);
#endif

#ifdef USE_TMS9918A
	initTMS9918A();
#endif
	puts("OK");

	if (debugger_enabled) {
		printf("  - DEBUGGER: ");
		db_init_ui(NULL);
		puts("OK");
	}

	printf("  - I8255: ");
	init8255();
	puts("OK");

	printf("  - I8253: ");
	//init8253();
	initPIT();
	puts("OK");

	//printf("  - TIMING: ");
	//inittiming();
	//puts("OK");

	//printf("  - GAMEPADS: ");
	//gamepad_init(&gp1);
	//gamepad_init(&gp2);
	//puts("OK");

	//printf("  - JOYSTICKS: ");
	//joystick_init();
	//puts("OK");

	//printf(" - SOUND: ");
	////ay8910_init_sound();
	//puts("OK");

	printf("  - CONSOLE: ");
	if (!SDL_CreateThread(console_thread, "V40EmuConsoleThread", NULL)) {
		fprintf(stderr, "Could not create console thread: %s\n", SDL_GetError());
		return;
	}
	puts("OK");

	starttick = SDL_GetTicks();
	perfFreq = (double)SDL_GetPerformanceFrequency();

	//TEST
	//tmsInitialiseText(tmsVDP.vdp);
	VDPinit();
}

void emu_tms9918a_tick() {
	lastTime = (double)SDL_GetPerformanceCounter() / perfFreq;
	double deltaTime = 0.0001;
	uint32_t deltaClockTicks = (uint32_t)(CPU_CLOCK * deltaTime);
	double currentTime = (double)SDL_GetPerformanceCounter() / perfFreq;

	if (currentTime - lastTime > 0.1) {
		lastTime = ((double)SDL_GetPerformanceCounter() / perfFreq) + deltaTime;
	}
	else {
		lastTime += deltaTime;
	}

	while ((currentTime = (double)SDL_GetPerformanceCounter() / perfFreq) < lastTime);

	//tick devices
	//tickTMS9918A(deltaClockTicks, (float)deltaTime);

	/*for (size_t i = 0; i < deviceCount; ++i)
	{
		tickDevice(&devices[i], deltaClockTicks, deltaTime);
	}*/
	//while (SDL_GetTicks() - lastTime < TICKS_FOR_NEXT_FRAME) {
	//    uint32_t clocks = 0;
	//    clocks = cpu_exec(1);
	//}

	///*tms9918a_rasterize(vdp);

	//if (!tms9918a_render(vdp_renderer)) {
	//    running = false;
	//}*/

	//if (debugger_enabled) {
	//    db_render_display(640, 480);
	//}
	//frame_count2++;
	//lastTime = SDL_GetTicks();
}

void emu_reset() {
	cpu_reset();

#ifdef USE_VERA
	vera_reset();
#endif

#ifdef USE_TMS9918A
	//resetTMS9918A();
	VDPreset(true);
#endif

	resetAY8910();

	if (hard_reset) {
		hard_reset = false;

		uint32_t size = load_bios("bios.bin");
		if (size <= 0) {
			printf("Error loading BIOS");
		}
	}

	reset_requested = false;
}

//void emu_loop() {
//
//	while (running) {
//
//		if (reset_requested) {
//			emu_reset();
//		}
//
//		if (debugger_enabled) {
//			int dbgCmd = db_get_current_status();
//			if (dbgCmd > 0) continue;
//			if (dbgCmd < 0) break;
//		}
//#ifdef USE_VERA
//		uint32_t clocks = 0;
//		bool new_frame = false;
//
//		clocks = cpu_exec(1);
//		new_frame |= vera_step(MHZ, clocks, false);
//		if (new_frame) {
//			if (!vera_update()) {
//				running = false;
//			}
//
//			if (debugger_enabled) {
//				db_render_display(640, 480);
//			}
//
//			frame_count2++;
//			timing();
//		}
//#endif
//
//#ifdef USE_TMS9918A
//
//		//emu_tms9918a_tick();
//
//#endif
//		if (cpu.hltstate) {
//			printf("HALT!!!!!");
//			running = false;
//		}
//
//	}
//}

static void doTick() {

	lastTime = (double)SDL_GetPerformanceCounter() / perfFreq;

	double deltaTime = 0.0001;
	uint32_t deltaClockTicks = (uint32_t)(CPU_SPEED * deltaTime);

	double currentTime = (double)SDL_GetPerformanceCounter() / perfFreq;

	if (currentTime - lastTime > 0.1) {
		lastTime = ((double)SDL_GetPerformanceCounter() / perfFreq) + deltaTime;
	}
	else {
		lastTime += deltaTime;
	}

	while ((currentTime = (double)SDL_GetPerformanceCounter() / perfFreq) < lastTime);


	/*for (size_t i = 0; i < deviceCount; ++i) {
		tickDevice(&devices[i], deltaClockTicks, deltaTime);
	}*/
}

static void doRender() {
	//renderTMS9918A();
}

static void doEvents() {
	SDL_Event event;
	while (SDL_PollEvent(&event)) {
		switch (event.type) {
			if (event.type == SDL_QUIT) {
				running = false;
				return;
			}
			if (event.type == SDL_WINDOWEVENT && event.window.event == SDL_WINDOWEVENT_CLOSE) {
				running = false;
				return;
			}
			else {
		case SDL_WINDOWEVENT:
			switch (event.window.event) {
			case SDL_WINDOWEVENT_CLOSE:
				running = false;
				break;

			default:
				break;
			}
			break;
			}
		}
	}
}

void emu_loop2() {
	static uint32_t lastRenderTicks = 0;
	
	doTick();

	++tickCount;

	uint32_t currentTicks = SDL_GetTicks();
	if ((currentTicks - lastRenderTicks) > 17) {
		doRender();

		lastRenderTicks = currentTicks;
		tickCount = 0;

		doEvents();

		SDL_snprintf(tempBuffer, sizeof(tempBuffer), "V40Emu (CPU: %0.4f%%) (ROM: %s)", 0f, /*getCpuUtilization(cpuDevice) * 100.0f*/ "bios.bin");
		SDL_SetWindowTitle(tmsVDP.window, tempBuffer);
	}
}

void emu_destroy() {

	if (debugger_enabled)
		db_free_ui();

#ifdef USE_VERA
	vera_end();
#endif

#ifdef USE_TMS9918A
	//destroyTMS9918A();
	VDPshutdown();
#endif

}

//static int emu_thread(void* ptr) {
//	puts("CPU: starting to execute.");
//
//	while (running) {
//		if (reset_requested) {
//			emu_reset();
//		}
//
//		if (debugger_enabled) {
//			int dbgCmd = db_get_current_status();
//			if (dbgCmd > 0) continue;
//			if (dbgCmd < 0) break;
//		}
//
//		uint32_t clocks = 0;
//		bool new_frame = false;
//
//		clocks = cpu_exec(1);
//
//		if (cpu.hltstate) {
//			printf("HALT!!!!!");
//			running = false;
//		}
//
//#ifdef USE_VERA
//		new_frame |= vera_step(MHZ, clocks, false);
//
//		if (new_frame) {
//			if (!vera_update()) {
//				running = false;
//			}
//
//			if (debugger_enabled) {
//				db_render_display(640, 480);
//			}
//
//			frame_count2++;
//		}
//#endif
//
//#ifdef USE_TMS9918A
//
//#endif
//
//		Sleep(1);
//	}
//}

int main(int argc, char** argv) {

	parsecl(argc, argv);

	emu_init();

	while (running) {
		emu_loop2();
	}

	//emu_loop();

	/*if (!SDL_CreateThread(emu_thread, "V40EmuThread", NULL)) {
		fprintf(stderr, "Could not create the main emuthread: %s\n", SDL_GetError());
		return -1;
	}*/

	/*while (running) {
		Sleep(1);
	}*/
	//emu_loop();

	endtick = (SDL_GetTicks() - starttick) / 1000;
	if (endtick == 0)
		endtick = 1; //avoid divide-by-zero exception in the code below, if ran for less than 1 second

	printf("\n%lu instructions executed in %lu seconds.\n", (long unsigned int)cpu.totalexec, (long unsigned int)endtick);
	printf("Average speed: %lu instructions/second.\n", (long unsigned int)(cpu.totalexec / endtick));

	//printf("NMI count: %d\n", ppu.nmi_count);
	printf("Frame count: %d\n", frame_count2);
	printf("Average FPS: %d\n", (long unsigned int)(frame_count2 / endtick));

	emu_destroy();

	return 0;
}
